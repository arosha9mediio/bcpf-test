/**
 * Dr.Kit
 * this is mediio Dr.Kit api server
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import {
  Controller,
  Get,
  Injectable,
  Param,
  Post,
  Res,
  UseGuards,
} from '@nestjs/common';
import {
  Args,
  ID,
  Mutation,
  ObjectType,
  Query,
  Resolver,
} from '@nestjs/graphql';
import { Response } from 'express';
import _ from 'lodash';
import { ConfigService } from '../config/config.service';
import {
  CurrentHeaders,
  Headers,
} from '../cores/decorators/headers.decorators';
import { Roles } from '../cores/decorators/roles.decorators';
import { CurrentUser } from '../cores/decorators/user.decorators';
import { GqlAuthGuard } from '../cores/guards/jwtAuth.guard';
import { AWSService } from '../util/aws.service';
import { DirectSendSMSDto } from '../util/dto/directSendDto';
import { decrypt, encrypt } from '../util/encryption';
import $ from '../util/exception.helper';
import { MessageService } from '../util/message.service';
import {
  GqlPaginatedResponse,
  PaginatedRequest,
  PaginatedResponse,
} from '../util/page';
import { ApplyUserDto } from './dto/applyUserDto';
import { ChangeUserPwDto } from './dto/changeUserPwDto';
import { ResetUserPwDto } from './dto/resetUserPwDto';
import { SendContactEmailDto } from './dto/sendContactEmailDto';
import { SendPwTokenEmailDto } from './dto/sendPwTokenEmailDto';
import { SignInDto } from './dto/signInDto';
import { UpdateUserDto } from './dto/updateUserDto';
import { UpdateUserProfileDto } from './dto/updateUserProfileDto';
import { UpdateUserStatusDto } from './dto/updateUserStatusDto';
import { User } from './user.entity';
import { UserService } from './user.service';
import { UserToken } from './userToken.entity';
import { CreateUserDto } from './dto/createUserDto';
import { SendPhoneVerifyTokenDto } from './dto/sendPhoneTokenDto';
import { UpdateUserPhoneDto } from './dto/updateUserPhoneDto';
// for graphql response
@ObjectType()
export class PaginatedUserResponse extends GqlPaginatedResponse(User) {}

@Injectable()
@Controller()
@Resolver(() => User)
export class UserController {
  constructor(
    private readonly userService: UserService,
    private readonly configService: ConfigService,
    private readonly mailService: MessageService,
    private readonly awsService: AWSService
  ) {}

  //---------------------------------//
  //---------------------------------//
  //---------------------------------//
  // 회원 정보 취득 프로세스              //
  // Getting user information        //
  //---------------------------------//
  //---------------------------------//
  //---------------------------------//
  //---------------------------------//
  /**
   * Get a user
   * it returns single user instance
   * @param id the user id to get a user.
   */
  @Query(() => User)
  @UseGuards(GqlAuthGuard)
  findUser(
    @Args('id', { type: () => ID, description: 'the user id to get a user.' })
    id: string,
    @CurrentUser() user: User
  ): Promise<User> {
    return this.userService.findUserById(id, undefined, undefined, user);
  }

  /**
   * Get user's own account info
   * @param user
   * @returns {User}
   */
  @Query(() => User)
  @UseGuards(GqlAuthGuard)
  getMe(@CurrentUser() user: User): User {
    return user;
  }

  //---------------------------------//
  //---------------------------------//
  //---------------------------------//
  // 회원, 의사, 매니저 등록 관련 프로세스 //
  //---------------------------------//
  //---------------------------------//
  //---------------------------------//
  //---------------------------------//

  @UseGuards(GqlAuthGuard)
  @Roles(User.RoleEnum.Admin)
  @Mutation(() => User)
  updateUser(
    @Args('updateUserDto', {
      type: () => UpdateUserDto,
      description: 'target user information',
    })
    updateUserDto: UpdateUserDto,
    @CurrentUser() user: User
  ): Promise<User> {
    return this.userService.updateUser(updateUserDto, user);
  }

  @UseGuards(GqlAuthGuard)
  @Roles(User.RoleEnum.Admin)
  @Mutation(() => User)
  updateUserStatus(
    @Args('updateUserStatusDto', {
      type: () => UpdateUserStatusDto,
      description: 'target user info',
    })
    updateUserStatusDto: UpdateUserStatusDto,
    @CurrentUser() user: User
  ): Promise<User> {
    return this.userService.updateUserStatus(updateUserStatusDto, user);
  }

  @UseGuards(GqlAuthGuard)
  @Mutation(() => Boolean)
  async updateUserProfile(
    @Args('updateUserProfileDto', {
      type: () => UpdateUserProfileDto,
      description: 'update user profile',
    })
    updateUserProfileDto: UpdateUserProfileDto,
    @CurrentUser() user: User
  ): Promise<boolean> {
    return this.userService.updateUserProfile(updateUserProfileDto, user);
  }

  @UseGuards(GqlAuthGuard)
  @Mutation(() => Boolean)
  async updateUserPhone(
    @Args('updateUserPhoneDto', {
      type: () => UpdateUserPhoneDto,
    })
    updateUserPhoneDto: UpdateUserPhoneDto,
    @CurrentUser() user: User
  ): Promise<boolean> {
    return this.userService.updateUserPhone(updateUserPhoneDto, user);
  }

  @Mutation(() => [String])
  async signIn(
    @Args('signInDto', { type: () => SignInDto })
    signInDto: SignInDto,
    @CurrentHeaders() headers: Headers
  ): Promise<string[]> {
    return this.userService.signIn(signInDto, headers);
  }

  @Mutation(() => String)
  validateRefreshJwt(
    @Args('token', { type: () => String })
    token: string
  ): Promise<string> {
    return this.userService.validateRefreshJwt(token);
  }

  // @UseGuards(GqlAuthGuard)
  // @Mutation(() => Boolean)
  // directSendSMS(
  //   @Args('directSendSMSDto') dto: DirectSendSMSDto
  // ): Promise<boolean> {
  //   return this.mailService.directSendSMS(dto);
  // }

  @UseGuards(GqlAuthGuard)
  @Mutation(() => String)
  changeUserPw(
    @Args('changeUserPwDto', {
      type: () => ChangeUserPwDto,
      description: 'change user password',
    })
    changeUserPwDto: ChangeUserPwDto,
    @CurrentUser() user: User
  ): Promise<string> {
    return this.userService.changeUserPw(changeUserPwDto, user);
  }

  @UseGuards(GqlAuthGuard)
  @Mutation(() => Boolean)
  deleteUser(
    @Args('id', { type: () => ID, description: 'the user id to get a user' })
    id: string,
    @CurrentUser() user: User
  ): Promise<boolean> {
    return this.userService.removeUser(id, user);
  }

  @Get('/user/apply/pw/:encKey')
  async verifyUserAppliedEncKey(
    @Param('encKey') encKey: string,
    @Res() res: Response
  ): Promise<void> {
    $.throwIfNot(encKey, '정보가 없거나 볼수 없습니다.');
    // 1. validate previous generated token
    const validatedUserToken = await this.userService.validateResetPwEncKey(
      encKey,
      UserToken.Type.Apply
    );

    // 2. generate new token to reset password
    const newVerificationToken =
      await this.userService.generateUserVerificationToken(
        new UserToken(
          validatedUserToken.userId,
          UserToken.Type.ResetPw,
          validatedUserToken.businessId
        )
      );

    // to delete used token
    this.userService.deleteUserToken(validatedUserToken.id);

    await this.userService.saveUserToken(
      _.omit(newVerificationToken, ['businessId'])
    );

    res.redirect(
      this.configService.static.admin +
        `/reset-password/${encrypt(
          JSON.stringify(newVerificationToken),
          this.configService.auth.jwtSecret
        )}`
    );
  }

  @Post('/user/send/email/pw')
  @Mutation(() => Boolean)
  sendPwTokenEmail(
    @Args('sendPwTokenEmailDto', {
      type: () => SendPwTokenEmailDto,
    })
    sendPwTokenEmailDto: SendPwTokenEmailDto
  ): Promise<boolean> {
    return this.userService.sendResetPwTokenEmail(sendPwTokenEmailDto);
  }

  @UseGuards(GqlAuthGuard)
  @Mutation(() => Boolean)
  sendPhoneVerifyToken(
    @CurrentUser() user: User,
    @Args('sendPhoneVerifyTokenDto', {
      type: () => SendPhoneVerifyTokenDto,
    })
    sendPhoneVerifyTokenDto: SendPhoneVerifyTokenDto
  ): Promise<boolean> {
    return this.userService.sendPhoneVerifyToken(user, sendPhoneVerifyTokenDto);
  }

  @Get('/user/reset/pw/:encKey')
  async verifyResetPwEncKey(
    @Param('encKey') encKey: string,
    @Res() res: Response
  ): Promise<void> {
    $.throwIfNot(encKey, '정보가 없거나 볼수 없습니다.');

    // 1. validate previous generated token
    const validatedUserToken = await this.userService.validateResetPwEncKey(
      encKey,
      UserToken.Type.FindPw
    );

    // 2. generate new token to reset password
    const newVerificationToken =
      await this.userService.generateUserVerificationToken(
        new UserToken(
          validatedUserToken.userId,
          UserToken.Type.ResetPw,
          validatedUserToken.businessId
        )
      );

    // to delete used token
    this.userService.deleteUserToken(validatedUserToken.id);
    await this.userService.saveUserToken(newVerificationToken);

    res.redirect(
      this.configService.static.front +
        `/auth/reset-password/${encrypt(
          JSON.stringify(newVerificationToken),
          this.configService.auth.jwtSecret
        )}`
    );
  }

  @Post('/user/reset/pw')
  @Mutation(() => Boolean)
  async resetPwWithEncKey(
    @Args('resetUserPwDto', { type: () => ResetUserPwDto, nullable: false })
    resetUserPwDto: ResetUserPwDto
  ): Promise<boolean> {
    return this.userService.resetPwWithEncKey(resetUserPwDto);
  }

  /**
   * Verify User Account
   */
  @Get('/user/register/:encKey')
  async verifyUserRrgisterEncKey(
    @Param('encKey') encKey: string,
    @Res() res: Response
  ): Promise<void> {
    $.throwIfNot(encKey, '정보가 없거나 볼수 없습니다.');

    // 1. validate previous generated token
    const validatedUserToken = await this.userService.validateResetPwEncKey(
      encKey,
      UserToken.Type.Register
    );

    // to delete used token
    this.userService.deleteUserToken(validatedUserToken.id);

    // activate user
    const utf8String = decrypt(encKey, this.configService.auth.jwtSecret);
    const userToken: UserToken = JSON.parse(utf8String);
    // const activateUser = await this.userService.activatePatient(userToken.userId);

    res.redirect(this.configService.static.front + `/auth/login`);
  }

  //------------------------------//
  //------------------------------//
  //-- 기타 서비스 --//
  //-- Etc  --//
  //------------------------------//
  //------------------------------//

  /**
   * Contact Us Email controller
   * 홈페이지의 컨텍트 어스에서 관리자에게 이메일을 전송.
   * @param sendContactEmailDto
   * @returns boolean
   */
  @Mutation(() => Boolean)
  async sendContactEmail(
    @Args('sendContactEmailDto', {
      type: () => SendContactEmailDto,
      description: 'Send Contact Us Email Data',
    })
    sendContactEmailDto: SendContactEmailDto
  ): Promise<boolean> {
    this.mailService.sendEmail({
      to: 'support@medigrant.com',
      subject: sendContactEmailDto.subject,
      text:
        sendContactEmailDto.name +
        '\n\n' +
        sendContactEmailDto.email +
        '\n\n' +
        sendContactEmailDto.message,
    });
    return true;
  }

  /**
   * Add a new User
   * only mediio manager can access this method.
   * @param createUserDto target user information
   * @param creator
   */
  @UseGuards(GqlAuthGuard)
  @Roles(User.RoleEnum.Admin)
  @Mutation(() => User)
  createUser(
    @Args('input', { type: () => CreateUserDto })
    createUserDto: CreateUserDto,
    @CurrentUser() creator: User
  ): Promise<User> {
    return this.userService.createUser(createUserDto, creator);
  }

  // @Query(() => PaginatedUserResponse)
  // // @UseGuards(GqlAuthGuard)
  // // @Roles(User.RoleEnum.Admin)
  // async findUsers(
  //   @Args('pageRequest', { type: () => PaginatedRequest, nullable: true })
  //   pageRequest: PaginatedRequest,
  // ) {
  //   const items = [
  //     (await this.userService.findUserById('1')) || { id: 1 },
  //     (await this.userService.findUserById('2')) || { id: 2 },
  //     (await this.userService.findUserById('3')) || { id: 3 },
  //   ];

  //   return new PaginatedResponse(items, 3, pageRequest);
  // }

  // todo -------------------------------------
  // @UseGuards(GqlAuthGuard)
  // @Query(() => String)
  // async getPreSignedUrl(
  //   @Args('mimetype', { type: () => String, nullable: false }) mimetype: string,
  //   @CurrentUser() user: User
  // ): Promise<string> {
  //   return this.awsService.getSignedUrlPromise(user.id, mimetype);
  // }

  // todo -------------------------------------
  // @UseGuards(GqlAuthGuard)
  // @Mutation(() => String)
  // async createPresignedPost(
  //   @Args('uploadPath', { type: () => String, nullable: false })
  //   uploadPath: string,
  //   @CurrentUser() user: User
  // ): Promise<string> {
  //   return this.awsService.createPresignedPost(user.id, uploadPath);
  // }

  @UseGuards(GqlAuthGuard)
  @Mutation(() => Boolean)
  @Roles(User.RoleEnum.Admin)
  async updateUserByAdmin(
    @Args('updateUserProfileDto', {
      type: () => UpdateUserProfileDto,
      description: 'update user profile',
    })
    updateUserProfileDto: UpdateUserProfileDto,
    @CurrentUser() user: User
  ): Promise<boolean> {
    return this.userService.updateUserByAdmin(updateUserProfileDto, user);
  }

  @UseGuards(GqlAuthGuard)
  @Mutation(() => Boolean)
  async updatePushToken(
    @Args('pushToken', { type: () => String, nullable: false })
    pushToken: string,
    @CurrentUser() user: User
  ): Promise<boolean> {
    return this.userService.updatePushToken(user, pushToken);
  }

  @UseGuards(GqlAuthGuard)
  @Roles(User.RoleEnum.Admin)
  @Query(() => PaginatedUserResponse)
  userFeed(
    @Args('pageRequest', { type: () => PaginatedRequest, nullable: true })
    pageRequest: PaginatedRequest,
    @CurrentUser() user: User
  ): Promise<PaginatedResponse<User>> {
    return this.userService.userFeed(user, PaginatedRequest.of(pageRequest));
  }
}
