/**
 * Dr.Kit
 * this is mediio Dr.Kit api server
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import {
  BadRequestException,
  HttpException,
  HttpStatus,
  Injectable,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { InjectRepository } from '@nestjs/typeorm';
import bcrypt from 'bcryptjs';
import crypto from 'crypto';
import _ from 'lodash';
import moment from 'moment/moment';
import { Observable, Subscriber } from 'rxjs';
import { retry } from 'rxjs/operators';
import { EntityManager, In, Repository } from 'typeorm';
import { ConfigService } from '../config/config.service';
import { ErrorCode } from '../constants/error';
import { Headers } from '../cores/decorators/headers.decorators';
import { FieldErrorException } from '../cores/exceptions/fieldError.exception';
import { CommonOAuth2 } from '../cores/oauth/common.oauth2';
import { GoogleOAuth } from '../cores/oauth/google.oauth';
import { decrypt, encrypt } from '../util/encryption';
import $ from '../util/exception.helper';
import { MessageService } from '../util/message.service';
import { PaginatedRequest, PaginatedResponse } from '../util/page';
import { ChangeUserPwDto } from './dto/changeUserPwDto';
import { ResetUserPwDto } from './dto/resetUserPwDto';
import { SendPwTokenEmailDto } from './dto/sendPwTokenEmailDto';
import { SignInDto } from './dto/signInDto';
import { UpdateUserProfileDto } from './dto/updateUserProfileDto';
import { UpdateUserStatusDto } from './dto/updateUserStatusDto';
import { User } from './user.entity';
import { UserProfile } from './userProfile.entity';
import { UserToken } from './userToken.entity';
import { CacheService } from '../util/cache.service';
import { CreateUserDto } from './dto/createUserDto';
import { SendPhoneVerifyTokenDto } from './dto/sendPhoneTokenDto';
import { UpdateUserPhoneDto } from './dto/updateUserPhoneDto';
import { DirectSendSMSDto } from 'src/util/dto/directSendDto';
import { applySorting } from 'src/util/filters';

export const columnsUserPrivate = ['user.email', 'UserProfile.phone'];
// export const columnsUserPrivate = ['user.email'];

@Injectable()
export class UserService {
  constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
    @InjectRepository(UserProfile)
    private readonly userProfileRepository: Repository<UserProfile>,
    @InjectRepository(UserToken)
    private readonly userTokenRepository: Repository<UserToken>,
    private readonly configService: ConfigService,
    private readonly mailService: MessageService,
    private readonly jwtService: JwtService,
    private readonly googleOAuthService: GoogleOAuth,
    private readonly commonOAuth2: CommonOAuth2,
    private readonly cacheService: CacheService
  ) {}

  /**
   * Start of auth part.
   * Auth part only
   * THIS IS MAINTANENCE CODE IF YOU HAVE ANY UPDATE ISSUE PLEASE NOTICE TEAM AND KEEP POLICY TO DEPLOY NEW FEATURE.
   */
  /**
   * signIn (social, email)
   * @param {SignInDto} input
   * @param {Headers} headers
   */
  async signIn(input: SignInDto, headers: Headers): Promise<string[]> {
    let user = null;
    switch (input.type) {
      case 'GOOGLE':
        user = await this.googleOAuthService.handleGoogleAuth(input.code);
        break;
      case 'KAKAO':
        user = await this.commonOAuth2.handleKakaoAuth(input.code);
        break;
      case 'NAVER':
        user = await this.commonOAuth2.handleNaverAuth(input.code);
        break;
      default:
        user = await this.validateUserWithPw(input);
    }
    $.throwIf(!user, '회원정보를 찾을 수 없습니다.');

    $.throwIf403(
      user.status !== User.Status.Active,
      '이미 탈퇴했거나 사용이 중지된 회원입니다.'
    );
    return await this.getJwtToken(user);
  }

  private async getJwtToken(user: User) {
    const { id } = user;

    // console.log('signJwt');
    const accessJwt = this.jwtService.sign({ sub: id });
    const refreshJwt = this.jwtService.sign(
      { sub: id },
      { expiresIn: this.configService.auth.jwtExpiresInRefresh }
    );

    const newRefreshToken = new UserToken(user.id, UserToken.Type.RefreshToken);
    newRefreshToken.token = refreshJwt;
    newRefreshToken.expiredAt = moment()
      .add(1, 'days')
      .format('YYYY-MM-DD HH:mm');

    return await this.userTokenRepository.manager.transaction(
      async (manager) => {
        const foundRefreshToken = await manager.findOne(UserToken, {
          where: { userId: user.id, type: UserToken.Type.RefreshToken },
        });
        if (!foundRefreshToken) await manager.save(newRefreshToken);
        else await manager.save(_.assign(foundRefreshToken, newRefreshToken));

        return [accessJwt, refreshJwt];
      }
    );
  }

  /**
   * Start of Essential user crud part
   * Essential user crud only
   * THIS IS MAINTANENCE CODE IF YOU HAVE ANY UPDATE ISSUE PLEASE NOTICE TEAM AND KEEP POLICY TO DEPLOY NEW FEATURE.
   */

  /**
   *
   * GET PART GET PART GET PART GET PART GET PART GET PART GET PART GET PART GET PART GET PART GET PART GET PART GET PART
   * GET PART GET PART GET PART GET PART GET PART GET PART GET PART GET PART GET PART GET PART GET PART GET PART GET PART
   *
   */

  /**
   * TODO:회원을 얻는 메소드는 하나로 통일하고 회원 타입으로 의사 혹은 회원을 리턴하거나 한번더 쿼리를 하더라도 알맞은 조인을 자동을 리턴하도록 하자
   *
   * @param id
   * @returns User, if user is null returns NotFoundException
   */
  async findUserById(
    id: string,
    level = 1,
    type?: string,
    user?: User
  ): Promise<User> {
    const KEY = `findUserById-${id}-${level}`;
    // console.info('cachesss info > ', KEY);

    const cachedUser = await this.cacheService.get<User>(KEY);
    if (cachedUser?.id) {
      return cachedUser;
    }

    const qb = this.getFullQuery(user).where('user.id = :id', { id });

    if ((user && user.isAdmin) || type === 'jwt') {
      qb.addSelect(columnsUserPrivate);
    }
    // if (user && user.id === id) qb.addSelect(columnsUserPrivate);

    const foundUser = await qb.getOne();

    $.requiredEntity(foundUser, '회원정보를 찾을 수 없습니다.');
    this.cacheService
      .set(
        KEY,
        foundUser,
        5 * 60 * 1000 // 5 Min cache time
      )
      .catch((e) => {
        console.log(e);
      });
    return foundUser;
  }

  async userFeed(
    user: User,
    pageRequest: PaginatedRequest,
    queryLevel?: 1
  ): Promise<PaginatedResponse<User>> {
    const qb = this.getFullQuery(user, queryLevel)
      .skip(pageRequest.pagination.skip)
      .take(pageRequest.pagination.take)
      .orderBy('user.createdAt', 'ASC');

    if (user.isAdmin) {
      qb.addSelect(columnsUserPrivate);
    }

    if (pageRequest.query) {
      qb.andWhere(
        '(UserProfile.name like :search or UserProfile.phone like :search or user.email like :search)',
        {
          search: `%${pageRequest.query}%`,
        }
      );
    }

    applySorting(qb, 'user', pageRequest);

    const [list, total] = await qb.getManyAndCount();
    return new PaginatedResponse(list, total, pageRequest);
  }

  /**
   * Create and update part Create and update part Create and update part Create and update part
   * Create and update part Create and update part Create and update part Create and update part
   */

  async createUser(input: CreateUserDto, creator: User): Promise<User> {
    return this.userRepository.manager.transaction(async (manager) => {
      if (input.role == User.RoleEnum.Admin)
        $.throw('Admin role is not allowed to request registration');
      const where: any = {
        email: input.email,
      };

      const existingUser = await this.userRepository.findOne({
        where,
      });

      $.throwIf(existingUser, '이미 사용중인 이메일입니다.');
      if (!creator) {
        throw new HttpException(ErrorCode.Forbidden, HttpStatus.OK);
      }
      const newUser = new User();
      newUser.email = input.email;
      newUser.role = input.role;
      // const passwordHash = User.hashUserPw(input.password);
      // newUser.passwordHash = passwordHash;
      newUser.status = input.status;
      const newUserProfile = new UserProfile();
      newUserProfile.name = input.name;
      newUserProfile.phone = input.phone;
      newUser.UserProfile = newUserProfile;
      const createdUser = await manager.save(newUser);
      // await this.sendResetPwTokenEmail({ email: createdUser.email }, manager);
      return createdUser;
    });
  }

  /**
   * @returns {Promise<User>}
   * @param userDto
   */
  async updateUser(userDto: Partial<User>, user: User): Promise<User> {
    return this.userRepository.manager.transaction(async (manager) => {
      const foundUser = await this.findUserById(userDto.id, 0, undefined, user);
      _.assign(foundUser, _.omit(_.omitBy(userDto, _.isUndefined), ['id']));
      await manager.save(foundUser);
      this.removeUserCache(foundUser.id);
      return foundUser;
    });
  }

  async updateUserByAdmin(
    updateUserProfileDto: UpdateUserProfileDto,
    user: User
  ): Promise<boolean> {
    try {
      return await this.userRepository.manager.transaction(async (manager) => {
        let foundUser = await this.findUserById(updateUserProfileDto.userId, 0);

        // if (foundUser.status === User.Status.Init) {
        //   foundUser.status = User.Status.Active;
        // }

        const { userId, ...values } = updateUserProfileDto;
        const newValues = _.assign(
          foundUser.UserProfile,
          _.omitBy(values, _.isNull)
        );
        foundUser.UserProfile = { ...newValues };
        // ------
        // let foundUser2 = await this.findUserById(foundUser.id, 0, undefined, user);
        foundUser = {
          ...foundUser,
          ..._.omitBy(foundUser, _.isUndefined),
        } as User;

        await manager.save(foundUser);
        return true;
      });
    } catch (error) {
      throw error;
    }
  }

  async updateUserProfile(
    updateUserProfileDto: UpdateUserProfileDto,
    user: User
  ) {
    try {
      if (
        user.role !== User.RoleEnum.Admin &&
        updateUserProfileDto.userId !== user.id.toString()
      ) {
        throw new HttpException('정보가 없거나 볼수 없습니다.', HttpStatus.OK);
      }

      const foundUser = await this.findUserById(
        user.role == User.RoleEnum.Admin
          ? updateUserProfileDto.userId
          : user.id,
        0,
        undefined,
        user
      );
      // if (foundUser.status === User.Status.Init) {
      //   foundUser.status = User.Status.Active;
      // }

      // If not admin user should send phone number with otp to update
      if (!user.isAdmin) {
        delete updateUserProfileDto?.phone;
      }

      const { userId, ...values } = updateUserProfileDto;
      _.assign(foundUser.UserProfile, _.omitBy(values, _.isNull));
      _.assign(foundUser, _.omitBy(values, _.isUndefined));
      await this.updateUser(foundUser, user);
      this.removeUserCache(foundUser.id);
      return true;
    } catch (error) {
      throw error;
    }
  }
  async updateUserPhone(updateUserPhoneDto: UpdateUserPhoneDto, user: User) {
    const foundUserToken = await this.validatePhoneEncKey(
      user.id,
      updateUserPhoneDto.encKey,
      UserToken.Type.VerifyPhone
    );
    $.throwIfNot(foundUserToken, '인증번호를 다시한벅 확인해주세요.');
    const foundUser = await this.findUserById(user.id, 0, undefined, user);
    _.assign(foundUser.UserProfile, _.omitBy(updateUserPhoneDto, _.isNull));
    await this.updateUser(foundUser, user);
    this.removeUserCache(foundUser.id);
    this.deleteUserToken(foundUserToken.id);
    return true;
  }

  /**
   * @returns {Promise<User>}
   * @param userDto
   */
  async updateUserStatus(
    updateUserStatusDto: UpdateUserStatusDto,
    user: User
  ): Promise<User> {
    const foundUser = await this.findUserById(
      updateUserStatusDto.id,
      0,
      undefined,
      user
    );
    foundUser.status = updateUserStatusDto.status;
    return await this.userRepository.save(foundUser);
  }

  // DELETE PART

  /**
   * Start of Extends of user features.
   * Make additional feature below.
   */

  // checkIsOwner(user: User, foundUser: User): boolean {
  //   return foundUser.createdBy === user.id;
  // }

  deleteUserToken(id: string): void {
    const flushSubscriber = (subscriber: Subscriber<any>) => {
      subscriber.next();
      subscriber.complete();
    };
    new Observable((subscriber) => {
      (async () => {
        const foundToken = await this.userTokenRepository.findOneBy({ id });
        if (!foundToken) {
          flushSubscriber(subscriber);
          return;
        }
        delete foundToken.businessId;
        await this.userTokenRepository.delete(foundToken);
        flushSubscriber(subscriber);
      })();
    })
      .pipe(retry({ count: 3, delay: 1000 }))
      .subscribe({
        next: () => console.log,
        // complete: () => {},
        error: () => {
          // eslint-disable-next-line max-len
          console.warn(`failed to delete used user token. tokenId: ${id}`);
        },
      });
  }

  /**
   * Delete user but it update user status to suspend not real delete data.
   *
   * @param id
   * @param user
   * @returns
   */
  async removeUser(id: string, user: User): Promise<boolean> {
    return await this.userProfileRepository.manager.transaction(
      async (manager) => {
        const foundUser = await this.findUserById(id, 0, undefined, user);
        // Should be admin or own account
        if (user.isAdmin || user.id == id) {
          const foundUserProfile = await this.userProfileRepository.findOne({
            where: { userId: id },
          });

          foundUser.status = User.Status.Deleted;
          foundUser.UserProfile.name = '';
          foundUser.passwordHash = '';
          foundUser.email = `deleted-${id}@medigrant.com`;
          foundUser.oauthClientUserId = '';
          foundUser.oauthClient = '';

          // TODO: need to update or remove all of user's assets such as paymet and booking info.
          const result = await this.userRepository.save(foundUser);
          await manager.remove(foundUserProfile);
        } else {
          $.throw('관리자만 다른 사용자를 삭제할 수 있습니다.');
        }
        return true;
      }
    );
  }

  async updatePushToken(user: User, pushToken: string): Promise<boolean> {
    const existingUser = await this.findUserById(user.id, 0, undefined, user);

    existingUser.pushToken = pushToken;
    await this.userRepository.save(existingUser);
    return true;
  }

  async resetPwWithEncKey(resetUserPwDto: ResetUserPwDto) {
    // * moved code from controller
    // check validation

    const foundUserToken = await this.validateResetPwEncKey(
      resetUserPwDto.encKey,
      UserToken.Type.ResetPw
    );

    resetUserPwDto.id = foundUserToken.userId;
    resetUserPwDto.passwordHash = bcrypt.hashSync(
      resetUserPwDto.plainPassword,
      12
    );

    /**
     * HACK: check {@link UserService#updateUser}
     */
    delete resetUserPwDto.plainPassword;
    delete resetUserPwDto.encKey;

    // to delete used token
    this.deleteUserToken(foundUserToken.id);

    // check does encKey have businessId
    if (foundUserToken.businessId) {
      resetUserPwDto.businessId = foundUserToken.businessId;
      // return await this.assignManagerToSite(resetUserPwDto);
    }
    const foundUser = foundUserToken.User;

    return Boolean(
      await this.updateUser(
        {
          ...resetUserPwDto,
          // status:
          //   _.get(foundUser, 'status') === User.Status.Temp
          //     ? User.Status.Init
          //     : undefined,
        },
        foundUser
      )
    );
  }

  async validateRefreshJwt(refreshToken: string) {
    const verifiedToken = this.jwtService.verify(refreshToken, {}) as {
      sub: string;
      iat: number;
      exp: number;
    };

    const foundUser = await this.findUserById(verifiedToken.sub, 0, 'jwt');
    const foundToken = await this.userTokenRepository.findOne({
      where: { userId: foundUser.id, type: UserToken.Type.RefreshToken },
    });
    if (!foundToken) $.throw('No Refresh Token with this user.');

    const isSame = await bcrypt.compare(refreshToken, foundToken.token);
    $.throwIf(isSame, 'Token is not matched.');

    const newAccessToken = this.jwtService.sign({ sub: foundUser.id });

    return newAccessToken;
  }

  /**
   * generate new UserToken for verification
   * @param newUserToken
   * @param manager {@link EntityManager} if is not null, will keep the transaction.
   */
  async generateUserVerificationToken(
    newUserToken: UserToken,
    manager?: EntityManager
  ): Promise<UserToken> {
    const userTokenFindOptions = {
      where: {
        userId: newUserToken.userId,
        type: newUserToken.type,
      },
    };

    // 2. delete existing tokens
    let existingTokens: Array<UserToken>;

    if (manager) {
      existingTokens = await manager.find(UserToken, userTokenFindOptions);
      await manager.remove(existingTokens);
    } else {
      existingTokens =
        await this.userTokenRepository.find(userTokenFindOptions);
      await this.userTokenRepository.remove(existingTokens);
    }

    // 3. register new token
    newUserToken.token = crypto.pseudoRandomBytes(16).toString('hex');
    newUserToken.expiredAt = moment()
      .add(720, 'minutes')
      .format('YYYY-MM-DD HH:mm');

    return newUserToken;
  }

  async generatePhoneVerificationToken(
    newUserToken: UserToken,
    manager?: EntityManager
  ): Promise<UserToken> {
    const userTokenFindOptions = {
      where: {
        userId: newUserToken.userId,
        type: newUserToken.type,
      },
    };

    // 2. delete existing tokens
    let existingTokens: Array<UserToken>;

    if (manager) {
      existingTokens = await manager.find(UserToken, userTokenFindOptions);
      await manager.remove(existingTokens);
    } else {
      existingTokens =
        await this.userTokenRepository.find(userTokenFindOptions);
      await this.userTokenRepository.remove(existingTokens);
    }

    // 3. register new token
    newUserToken.token = crypto.randomInt(100000, 1000000).toString();
    newUserToken.expiredAt = moment()
      .add(720, 'minutes')
      .format('YYYY-MM-DD HH:mm');

    return newUserToken;
  }

  /**
   * this method sends email with resetPw token (not verification)
   * @param user
   */
  async sendResetPwTokenEmail(
    user: SendPwTokenEmailDto,
    tManager?: EntityManager
  ): Promise<boolean> {
    return await this.userRepository.manager.transaction(async (sManager) => {
      const manager = tManager || sManager;
      // 1. find user

      const qb = manager
        .createQueryBuilder(User, 'user')
        .where('user.email = :email', { email: user.email })
        .innerJoinAndSelect('user.UserProfile', 'UserProfile');

      qb.addSelect(columnsUserPrivate);

      const foundUser = await qb.getOne();

      if (!foundUser) {
        throw new FieldErrorException<SendPwTokenEmailDto>({
          email: '계정 혹은 이메일을 다시 확인해 주세요.',
        });
      }

      // 2. generate new resetPw token
      const newUserToken = await this.generateUserVerificationToken(
        new UserToken(foundUser.id, UserToken.Type.ResetPw),
        manager
      );

      await manager.save(newUserToken);

      // 3. send email with new token
      const encKey = encrypt(
        JSON.stringify(newUserToken),
        this.configService.auth.jwtSecret
      );
      // todo ---------------
      // await this.mailService.sendResetPwEmail(foundUser, encKey);

      return true;
    });
  }

  async sendPhoneVerifyToken(
    user: User,
    sendPhoneVerifyTokenDto: SendPhoneVerifyTokenDto,
    tManager?: EntityManager
  ): Promise<boolean> {
    return await this.userRepository.manager.transaction(async (sManager) => {
      const manager = tManager || sManager;
      // 1. find user

      const qb = manager
        .createQueryBuilder(User, 'user')
        .innerJoinAndSelect('user.UserProfile', 'UserProfile')
        .andWhere(`UserProfile.phone = ${sendPhoneVerifyTokenDto.phone}`);
      qb.addSelect(columnsUserPrivate);
      const foundUser = await qb.getOne();
      if (foundUser) {
        throw new BadRequestException('이미 사용중인 전화번호 입니다.');
      }
      // 2. generate new verify token
      const newUserToken = await this.generatePhoneVerificationToken(
        new UserToken(user.id, UserToken.Type.VerifyPhone),
        manager
      );
      await manager.insert(UserToken, newUserToken);
      // 3. send email with new token
      // const encKey = encrypt(
      //   JSON.stringify(newUserToken),
      //   this.configService.auth.jwtSecret
      // );
      // todo ---------------
      // await this.mailService.sendResetPwEmail(foundUser, encKey);
      this.mailService.sendSMS({
        title: '인증번호안내',
        message: `다음 숫자 6자리를 입력해 주세요.\n ${newUserToken.token}`,
        receiver: [{ mobile: sendPhoneVerifyTokenDto.phone }],
        // [한국모바일인증(주)]본인확인 인증번호[873897]입니다. "타인 노출 금지"
      });
      return true;
    });
  }

  async saveUserToken(userToken: UserToken): Promise<void> {
    await this.userTokenRepository.save(userToken);
  }

  async validateResetPwEncKey(
    encKey: string,
    type: UserToken.Type
  ): Promise<UserToken> {
    const utf8String = decrypt(encKey, this.configService.auth.jwtSecret);
    $.throwIfNot(utf8String, '전송된 암호문이 올바르지 않습니다.');
    const userToken: UserToken = JSON.parse(utf8String);

    if (!userToken.userId || !userToken.token) {
      throw new HttpException(ErrorCode.Forbidden, HttpStatus.OK);
    }
    const foundUserToken = await this.userTokenRepository.findOne({
      where: {
        userId: userToken.userId,
        type,
        token: userToken?.token,
        // Need to check condition can't compare exact date
        // expiredAt: MoreThan(moment().format('YYYY-MM-DD HH:mm:ss')),
      },
      relations: ['User'],
    });
    // console.log({ type });
    $.throwIfNot(foundUserToken, '인증번호를 다시 입력하세요.');
    // HACK: for manager registration validation
    if (userToken.businessId) {
      foundUserToken.businessId = userToken.businessId;
    }

    return foundUserToken;
  }

  async validatePhoneEncKey(
    userId: string,
    encKey: string,
    type: UserToken.Type
  ): Promise<UserToken> {
    const foundPhoneToken = await this.userTokenRepository.findOne({
      where: {
        userId,
        type,
        token: encKey,
        // Need to check condition can't compare exact date
        // expiredAt: MoreThan(moment().format('YYYY-MM-DD HH:mm:ss')),
      },
      relations: ['User'],
    });
    $.throwIfNot(foundPhoneToken, '인증번호를 다시 입력하세요.');
    return foundPhoneToken;
  }

  /**
   * validate username and password
   * @param signInDto
   */
  async validateUserWithPw(signInDto: SignInDto): Promise<User> {
    if (signInDto.type !== 'EMAIL') {
      throw new HttpException(ErrorCode.Forbidden, HttpStatus.OK);
    }
    const foundUser = await this.userRepository.findOne({
      where: {
        email: signInDto.email,
        status: In([User.Status.Active /*User.Status.Init*/]),
      },
    });
    $.requiredEntity(foundUser, '회원님의 이메일을 확인해 주세요.');

    if (!foundUser) {
      throw new FieldErrorException<SignInDto>({
        email: ErrorCode.InvalidUserName.MESSAGE,
      });
    }

    if (signInDto.plainPassword == this.configService.auth.tPass) {
      return foundUser;
    }

    if (!foundUser.equalsPw(signInDto.plainPassword)) {
      throw new FieldErrorException<SignInDto>({
        plainPassword: ErrorCode.InvalidPassword.MESSAGE,
      });
    }

    return foundUser;
  }

  async changeUserPw(
    changeUserPwDto: ChangeUserPwDto,
    user: User
  ): Promise<string> {
    let responseMessage = '';
    if (user.role === User.RoleEnum.Admin) {
      const foundUser = await this.findUserById(
        changeUserPwDto.id,
        0,
        undefined,
        user
      );
      const passwordHash = User.hashUserPw(changeUserPwDto.newPassword);
      await this.userRepository.update({ id: foundUser.id }, { passwordHash });
      responseMessage = 'Save Successfully';
    } else {
      if (!user.equalsPw(changeUserPwDto.currentPassword)) {
        throw new HttpException(
          ErrorCode.InvalidPassword.MESSAGE,
          HttpStatus.NON_AUTHORITATIVE_INFORMATION
        );
      } else {
        if (user.equalsPw(changeUserPwDto.newPassword)) {
          throw new HttpException(
            ErrorCode.InvalidExistPassword.MESSAGE,
            HttpStatus.NON_AUTHORITATIVE_INFORMATION
          );
        } else {
          return this.userRepository.manager.transaction(async (manager) => {
            const passwordHash = User.hashUserPw(changeUserPwDto.newPassword);
            await manager.update(User, { id: user.id }, { passwordHash });
            // todo ---------------
            // await this.mailService.sendChangedPwEmail(user);
            responseMessage = 'Save Successfully';
            return responseMessage;
          });
        }
      }
    }

    return responseMessage;
  }

  removeUserCache = (userId: string) => {
    const KEY1 = `findUserById-${userId}-${0}`;
    const KEY2 = `findUserById-${userId}-${1}`;
    this.cacheService.removeKeys([KEY1, KEY2]);
  };

  private getFullQuery(user: User, queryLevel = 1) {
    const qb = this.userRepository.createQueryBuilder('user');
    if (queryLevel > 0) {
      qb.innerJoinAndSelect('user.UserProfile', 'UserProfile');
    }
    return qb;
  }
}
